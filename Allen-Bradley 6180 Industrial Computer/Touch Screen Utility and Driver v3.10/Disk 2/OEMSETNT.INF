;****************************************************************************
;
;				Copyright(C) Dynapro Technologies Inc., 1995.
;
; File:			$Workfile:   pc2nt3.inf  $
;
; Revision:		$Revision:   1.3  $
;
; Summary:		Install script file for Dynapro Thin Film software.
;
; Description:	This file is used to install the Dynapro Thin Film 
;				drivers and utilities on a Windows NT platform.
;
; Notes:		This file is derived from instfnt.inf.
;
;****************************************************************************

;-----------------------------------------------------------------------
; OPTION TYPE
; -----------
; This identifies the Option type we are dealing with.  The different
; possible types are:
;
; COMPUTER, VIDEO, POINTER, KEYBOARD, LAYOUT, SCSI, PRINTER, ...
;-----------------------------------------------------------------------

[Identification]
    OptionType = POINTER

;-----------------------------------------------------------------------
; LANGUAGES SUPPORTED
; -------------------
;
; The languages supported by the INF, For every language supported
; we need to have a separate text section for every displayable text
; section.
;
;-----------------------------------------------------------------------

[LanguagesSupported]
    ENG

;-----------------------------------------------------------------------
; OPTION LIST
; -----------
; This section lists the Option key names.  These keys are locale
; independent and used to represent the option in a locale independent
; manner.
;
;-----------------------------------------------------------------------

[Options]
    PC1NT  = ePC2nt  , mouclass
    PC2NT  = ePC2nt  , mouclass

;
; This maps detected options into the options we support
;
; Format: DetectedOption = MappedOption
;

[MapOfOptions]
	"Dynapro Thin Film PC1 Touch Screen Driver"		= PC1NT
	"Dynapro Thin Film PC2 Touch Screen Driver"		= PC2NT

;
; Order of the information:
;
; Port driver = Type, Group, ErrorControl, Tag, EventMessageFile, TypesSupported
;

[PortDrivers]
    ePC2nt = !SERVICE_KERNEL_DRIVER, "Pointer Port",  !SERVICE_ERROR_IGNORE, 2, "%SystemRoot%\System32\IoLogMsg.dll;%SystemRoot%\System32\drivers\ePC2nt.sys" , 7

;
; Order of the information:
;
; Class driver = Type, Group, ErrorControl, Tag, EventMessageFile, TypesSupported
;

[ClassDrivers]

    mouclass = !SERVICE_KERNEL_DRIVER, "Pointer Class", !SERVICE_ERROR_NORMAL, 1, "%SystemRoot%\System32\IoLogMsg.dll;%SystemRoot%\System32\drivers\mouclass.sys" , 7

    kbdclass = !SERVICE_KERNEL_DRIVER, "Keyboard Class", !SERVICE_ERROR_NORMAL, 1, "%SystemRoot%\System32\IoLogMsg.dll;%SystemRoot%\System32\drivers\kbdclass.sys" , 7

;-----------------------------------------------------------------------
; OPTION TEXT SECTION
; -------------------
; These are text strings used to identify the option to the user.  There
; are separate sections for each language supported.  The format of the
; section name is "OptionsText" concatenated with the Language represented
; by the section.
;
;-----------------------------------------------------------------------

[OptionsTextENG]
    PC1NT  = "Dynapro Thin Film PC1 Touch Screen Driver"
    PC2NT  = "Dynapro Thin Film PC2 Touch Screen Driver"

;---------------------------------------------------------------------------
; 1. Identify
;
; DESCRIPTION:   To verify that this INF deals with the same type of options
;                as we are choosing currently.
;
; INPUT:         None
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Option Type (COMPUTER ...)
;                $($R2): Diskette description
;---------------------------------------------------------------------------

[Identify]
    ;
    ;
    read-syms Identification

    set Status     = STATUS_SUCCESSFUL
    set Identifier = $(OptionType)
    set Media      = #("Source Media Descriptions", 1, 1)

    Return $(Status) $(Identifier) $(Media)



;------------------------------------------------------------------------
; 2. ReturnOptions:
;
; DESCRIPTION:   To return the option list supported by this INF and the
;                localised text list representing the options.
;
;
; INPUT:         $($0):  Language used. ( ENG | FRN | ... )
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL |
;                                STATUS_NOLANGUAGE
;                                STATUS_FAILED
;
;                $($R1): Option List
;                $($R2): Option Text List
;------------------------------------------------------------------------

[ReturnOptions]
    ;
    ;
    set Status        = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) in $(LanguageList)
        goto returnoptions
    else
        set Status = STATUS_NOLANGUAGE
        goto finish_ReturnOptions
    endif

    ;
    ; form a list of all the options and another of the text representing
    ;

returnoptions = +
    set OptionList     = ^(Options, 0)
    set OptionTextList = ^(OptionsText$($0), 1)
    set Status         = STATUS_SUCCESSFUL

finish_ReturnOptions = +
    Return $(Status) $(OptionList) $(OptionTextList)


;---------------------------------------------------------------------------
; MapToSupportedOption
;
; DESCRIPTION:   To map a hardware detected option to the NT Supported
;                option which represents it.
;
; INPUT:         $($0): Option
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Mapped Option
;
;---------------------------------------------------------------------------

[MapToSupportedOption]
    ;
    set Status = STATUS_SUCCESSFUL
    set MappedOption = $($0)

    ;
    ; If the option is one we can support using one of our standard options
    ; then map it to the standard option.  If not just pass it back as an
    ; unknown option
    ;

    set OptionList = ^(MapOfOptions, 0)
    ifcontains $($0) in $(OptionList)
        set MappedOption = #(MapOfOptions, $($0), 1)
    else
		set Status = STATUS_FAILED
;        set MappedOption = "UNKNOWN"
    endif

    Return $(Status) $(MappedOption)


[ServicesEntry]
    CurrentPortEntry	= "" ? $(!LIBHANDLE) GetDevicemapValue PointerPort  \Device\PointerPort0
    CurrentClassEntry	= "" ? $(!LIBHANDLE) GetDevicemapValue PointerClass \Device\PointerClass0
    CurrentKbdEntry		= "" ? $(!LIBHANDLE) GetDevicemapValue KeyboardClass \Device\KeyboardClass0

;
; InstallOption:
;
; FUNCTION:  To copy files representing Options
;            To configure the installed option
;            To update the registry for the installed option
;
; INPUT:     $($0):  Language to use
;            $($1):  OptionID to install
;            $($2):  SourceDirectory
;            $($3):  AddCopy  (YES | NO)
;            $($4):  DoCopy   (YES | NO)
;            $($5):  DoConfig (YES | NO)
;
; OUTPUT:    $($R0): STATUS: STATUS_SUCCESSFUL |
;                            STATUS_NOLANGUAGE |
;                            STATUS_USERCANCEL |
;                            STATUS_FAILED
;

[InstallOption]

	;
	; DEBUG
	;
;	set !STF_DISPLAYDEBUGOUTPUT	= 1

	;
	; Set magic value to tell setup service to not change
	; a service parameter.  Why is this value used?  Who knows.
	;
	set SERVICE_NO_CHANGE = 4294967295

    ;
    ; Set default values for
    ;
    set Status   = STATUS_FAILED
    set DrivesToFree = {}

    ;
    ; extract parameters
    ;
    set Option   = $($1)
    set SrcDir   = $($2)
    set AddCopy  = $($3)
    set DoCopy   = $($4)
    set DoConfig = $($5)

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) in $(LanguageList)
    else
        set Status = STATUS_NOLANGUAGE
        goto finish_InstallOption
    endif
    read-syms Strings$($0)

    ;
    ; check to see if Option is supported.
    ;

    set OptionList = ^(Options, 0)
    ifcontains $(Option) in $(OptionList)
    else
        goto finish_InstallOption
    endif
    set OptionList = ""

    ;
    ; find out the current pointer port and class services entries,
    ; and the new port driver and class driver to install
    ;

    read-syms ServicesEntry
    detect    ServicesEntry

    Debug-Output "ERGO.INF: Current Port Entry is:     "$(CurrentPortEntry)
    Debug-Output "ERGO.INF: Current Class Entry is:    "$(CurrentClassEntry)
    Debug-Output "ERGO.INF: Current Keyboard Entry is: "$(CurrentKbdEntry)

    set PortDriver  = #(Options, $(Option), 1)
    set ClassDriver = #(Options, $(Option), 2)

    Debug-Output "ERGO.INF: New Port Entry is:      "$(PortDriver)
    Debug-Output "ERGO.INF: New Class Entry is:     "$(ClassDriver)

    ;
    ; Check if current option is NONE or UNKNOWN, then we don't need to copy
    ; any files.  Set the AddCopy and DoCopy variables to NO
    ;

    ifstr(i) $(Option) == NONE
        set AddCopy = NO
        set DoCopy  = NO
    else-ifstr(i) $(Option) == UNKNOWN
        set AddCopy = NO
        set DoCopy  = NO
    endif


installtheoption = +

    ;
    ; Code to add files to copy list
    ;

    ifstr(i) $(AddCopy) == "YES"
        set DoActualCopy = NO
        set FileToCheck = #(Files-ErgoTouchDrivers, $(PortDriver), 2)
        LibraryProcedure STATUS,$(!LIBHANDLE),CheckFileExistance $(!STF_WINDOWSSYSPATH)"\drivers\"$(FileToCheck)
        ifstr(i) $(STATUS) == NO
            set DoActualCopy = YES
        endif

        ifstr(i) $(DoActualCopy) == NO
            shell "subroutn.inf" DriversExist $($0) $(String1)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "ERGO.INF: shelling DriversExist failed"
                goto finish_InstallOption
            endif

            ifstr(i) $($R0) == STATUS_CURRENT
            else-ifstr(i) $($R0) == STATUS_NEW
                set DoActualCopy = YES
            else-ifstr(i) $($R0) == STATUS_USERCANCEL
                Debug-Output "ERGO.INF: User cancelled Pointer installation"
                goto finish_InstallOption
            else
                Debug-Output "ERGO.INF: Error reported in DriversExist routine in SUBROUTN.INF"
                goto finish_InstallOption
            endif
        endif

        ifstr(i) $(DoActualCopy) == YES

            shell "subroutn.inf" DoAskSourceEx $(SrcDir) $(String2)
            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "ERGO.INF: shelling DoAskSourceEx failed"
                goto finish_InstallOption
            endif

            ifstr(i) $($R0) == STATUS_SUCCESSFUL
                set SrcDir = $($R1)
                ifstr(i) $($R2) != ""
                    set DrivesToFree = >($(DrivesToFree), $($R2))
                endif
            else
                Debug-Output "ERGO.INF: User cancelled asking source."
                goto finish_InstallOption
            endif

            install Install-AddCopyOption
            ifstr(i) $(STF_INSTALL_OUTCOME) != "STF_SUCCESS"
                Debug-Output "ERGO.INF: Adding mouse files to copy list failed"
                goto finish_InstallOption
            endif
        else
            set DoCopy = NO
        endif

    endif

    ifstr(i) $(DoCopy) == "YES"
        read-syms ProgressCopy$($0)
		Install Install-ErgoDir
        install Install-DoCopyOption
        ifstr(i) $(STF_INSTALL_OUTCOME) == "STF_FAILURE"
            Debug-Output "ERGO.INF: Copying files failed"
            goto finish_InstallOption
        else-ifstr(i) $(STF_INSTALL_OUTCOME) == "STF_USERQUIT"
            set Status = STATUS_USERCANCEL
            goto finish_InstallOption
        endif
    endif

    ifstr(i) $(DoConfig) == "YES"
        ;
        ; first run a privilege check on modifying the setup node
        ;

        shell "registry.inf" CheckSetupModify
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto finish_InstallOption
        endif

        ifstr(i) $($R0) != STATUS_SUCCESSFUL
            goto finish_InstallOption
        endif

        ;
		; Make an entry in the services key for the ErgoTouch driver.
		; The driver is created in an enabled state.
        ;

        ifstr(i) $(PortDriver) != ""

			Debug-Output "ERGO.INF: Adding service $(PortDriver)"

			set ServiceNode			= $(PortDriver)
            set ServiceBinary		= %SystemRoot%\System32\drivers\#(Files-ErgoTouchDrivers, $(PortDriver), 2)
			set Type				= $(#(PortDrivers, $(PortDriver), 1))
			set Group				=   #(PortDrivers, $(PortDriver), 2)
			set ErrorControl		= $(#(PortDrivers, $(PortDriver), 3))
			set Tag					=   #(PortDrivers, $(PortDriver), 4)
            set EventMessageFile	=   #(PortDrivers, $(PortDriver), 5)
            set TypesSupported		=   #(PortDrivers, $(PortDriver), 6)

            set ServicesValues   = { +
                    {Type,           0, $(!REG_VT_DWORD),     $(Type)                  }, +
                    {Start,          0, $(!REG_VT_DWORD),     $(!SERVICE_SYSTEM_START) }, +
                    {Group,          0, $(!REG_VT_SZ),        $(Group)                 }, +
                    {ErrorControl,   0, $(!REG_VT_DWORD),     $(ErrorControl)          }, +
                    {Tag,            0, $(!REG_VT_DWORD),     $(Tag)                   }, +
                    {BinaryPathName, 0, $(!REG_VT_EXPAND_SZ), $(ServiceBinary)         }  +
                    }

			set MouseDataQueueSize		= 100
			set NumberOfButtons			= 2
			set PointerDeviceBaseName	= PointerPort
			set SampleRate				= 40

            ifstr(i) $(Option) == PC1NT
			    set ParametersValues = { +
                    {MouseDataQueueSize,    0, $(!REG_VT_DWORD), $(MouseDataQueueSize) }, +
                    {NumberOfButtons,       0, $(!REG_VT_DWORD), $(NumberOfButtons) }, +
                    {PointerDeviceBaseName, 0, $(!REG_VT_SZ),    $(PointerDeviceBaseName) }, +
                    {SampleRate,            0, $(!REG_VT_DWORD), $(SampleRate) } +
                    {"TSC Interface",       0, $(!REG_VT_BIN),   {73, 82, 81, 61, 57, 13, 10, 73, 79, 65, 100, 100, 114, 61, 56, 48, 48, 13, 10, 80, 114, 111, 116, 111, 99, 111, 108, 61, 51, 13, 10, 0 } } +
                }
            else
			    set ParametersValues = { +
                    {MouseDataQueueSize,    0, $(!REG_VT_DWORD), $(MouseDataQueueSize) }, +
                    {NumberOfButtons,       0, $(!REG_VT_DWORD), $(NumberOfButtons) }, +
                    {PointerDeviceBaseName, 0, $(!REG_VT_SZ),    $(PointerDeviceBaseName) }, +
                    {SampleRate,            0, $(!REG_VT_DWORD), $(SampleRate) } +
                    {"TSC Interface",       0, $(!REG_VT_BIN),   {73, 82, 81, 61, 57, 13, 10, 73, 79, 65, 100, 100, 114, 61, 56, 48, 48, 13, 10, 80, 114, 111, 116, 111, 99, 111, 108, 61, 52, 13, 10, 0 } } +
                }
            endif

            set DeviceValues     = {}
            set EventLogValues   = { +
;                    {EventMessageFile, 0, $(!REG_VT_EXPAND_SZ), $(EventMessageFile) }, +
;                    {TypesSupported,   0, $(!REG_VT_DWORD),     $(TypesSupported)   }  +
                    }

            shell "registry.inf"  MakeServicesEntry $(ServiceNode)      +
                                                    $(ServicesValues)   +
                                                    $(ParametersValues) +
                                                    $(DeviceValues)     +
                                                    $(EventLogValues)   +
                                                    Parameters

            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "ERGO.INF: Couldn't execute MakeServicesEntry in registry.inf"
                goto errorconfig
            endif

            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "ERGO.INF: MakeServicesEntry failed for pointer"
                goto errorconfig
            endif

        endif

        ;
        ; Set up the Class Driver service entry.  It may already exist,
		; so this just overrides the current configuration.
        ;

        ifstr(i) $(ClassDriver) != ""

			Debug-Output "ERGO.INF: Modifying service $(ClassDriver)"

            set ServiceNode   = $(ClassDriver)
            set ServiceBinary = %SystemRoot%\System32\drivers\#(Files-MouseClassDrivers, $(ClassDriver), 2)
            set Type             = $(#(ClassDrivers, $(ClassDriver), 1))
            set Group            =   #(ClassDrivers, $(ClassDriver), 2)
            set ErrorControl     = $(#(ClassDrivers, $(ClassDriver), 3))
            set Tag              =   #(ClassDrivers, $(ClassDriver), 4)
            set EventMessageFile =   #(ClassDrivers, $(ClassDriver), 5)
            set TypesSupported   =   #(ClassDrivers, $(ClassDriver), 6)

            set ServicesValues   = { +
                    {Type,           0, $(!REG_VT_DWORD),     $(Type)                  }, +
                    {Start,          0, $(!REG_VT_DWORD),     $(!SERVICE_SYSTEM_START) }, +
                    {Group,          0, $(!REG_VT_SZ),        $(Group)                 }, +
                    {ErrorControl,   0, $(!REG_VT_DWORD),     $(ErrorControl)          }, +
                    {Tag,            0, $(!REG_VT_DWORD),     $(Tag)                   }, +
                    {BinaryPathName, 0, $(!REG_VT_EXPAND_SZ), $(ServiceBinary)         }  +
                    }

			set ConnectMultiplePorts	= 1
			set MaximumPortsServiced	= 3
			set ClassDataQueueSize		= 100
			set PointerClassBaseName	= PointerClass
			set ParametersValues = { +
					{ConnectMultiplePorts,	0, $(!REG_VT_DWORD),	$(ConnectMultiplePorts)	}, +
					{MaximumPortsServiced,	0, $(!REG_VT_DWORD),	$(MaximumPortsServiced)	}, +
					{MouseDataQueueSize,	0, $(!REG_VT_DWORD),	$(ClassDataQueueSize)	}, +
					{PointerDeviceBaseName,	0, $(!REG_VT_SZ),		$(PointerClassBaseName)	} +
					}

            set DeviceValues     = {}
            set EventLogValues   = { +
                    {EventMessageFile, 0, $(!REG_VT_EXPAND_SZ), $(EventMessageFile) }, +
                    {TypesSupported,   0, $(!REG_VT_DWORD),     $(TypesSupported)   }  +
                    }

            shell "registry.inf"  MakeServicesEntry $(ServiceNode)      +
                                                    $(ServicesValues)   +
                                                    $(ParametersValues) +
                                                    $(DeviceValues)     +
                                                    $(EventLogValues)   +
                                                    Parameters


            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "ERGO.INF: Couldn't execute MakeServicesEntry in registry.inf"
                goto errorconfig
            endif

            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "ERGO.INF: MakeServicesEntry failed for Mouclass"
                goto errorconfig
            endif

        endif

        ;
        ; Set up the Keyboard Class Driver service entry.
		; This just overrides the current configuration.
        ;

        ifstr(i) $(CurrentKbdEntry) != ""

			Debug-Output "ERGO.INF: Modifying service $(CurrentKbdEntry)"

            set ServiceNode   = $(CurrentKbdEntry)
            set ServiceBinary = %SystemRoot%\System32\drivers\#(Files-KeyboardClassDrivers, $(CurrentKbdEntry), 2)

            set Type             = $(#(ClassDrivers, $(CurrentKbdEntry), 1))
            set Group            =   #(ClassDrivers, $(CurrentKbdEntry), 2)
            set ErrorControl     = $(#(ClassDrivers, $(CurrentKbdEntry), 3))
            set Tag              =   #(ClassDrivers, $(CurrentKbdEntry), 4)
            set EventMessageFile =   #(ClassDrivers, $(CurrentKbdEntry), 5)
            set TypesSupported   =   #(ClassDrivers, $(CurrentKbdEntry), 6)

            set ServicesValues   = { +
                    {Type,           0, $(!REG_VT_DWORD),     $(Type)                  }, +
                    {Start,          0, $(!REG_VT_DWORD),     $(!SERVICE_SYSTEM_START) }, +
                    {Group,          0, $(!REG_VT_SZ),        $(Group)                 }, +
                    {ErrorControl,   0, $(!REG_VT_DWORD),     $(ErrorControl)          }, +
                    {Tag,            0, $(!REG_VT_DWORD),     $(Tag)                   }, +
                    {BinaryPathName, 0, $(!REG_VT_EXPAND_SZ), $(ServiceBinary)         }  +
                    }

			set ConnectMultipleKbds		= 1
			set MaximumKbdsServiced		= 3
			set KbdDataQueueSize		= 100
			set KbdDeviceBaseName		= KeyboardClass
			set ParametersValues = { +
					{ConnectMultiplePorts,	0, $(!REG_VT_DWORD),	$(ConnectMultipleKbds)	}, +
					{MaximumPortsServiced,	0, $(!REG_VT_DWORD),	$(MaximumKbdsServiced)	}, +
					{KeyboardDataQueueSize,	0, $(!REG_VT_DWORD),	$(KbdDataQueueSize)		}, +
					{KeyboardDeviceBaseName,0, $(!REG_VT_SZ),		$(KbdDeviceBaseName)	} +
					}

            set DeviceValues     = {}
            set EventLogValues   = { +
                    {EventMessageFile, 0, $(!REG_VT_EXPAND_SZ), $(EventMessageFile) }, +
                    {TypesSupported,   0, $(!REG_VT_DWORD),     $(TypesSupported)   }  +
                    }

            shell "registry.inf"  MakeServicesEntry $(ServiceNode)      +
                                                    $(ServicesValues)   +
                                                    $(ParametersValues) +
                                                    $(DeviceValues)     +
                                                    $(EventLogValues)   +
                                                    Parameters


            ifint $($ShellCode) != $(!SHELL_CODE_OK)
                Debug-Output "ERGO.INF: Couldn't execute MakeServicesEntry in registry.inf"
                goto errorconfig
            endif

            ifstr(i) $($R0) != STATUS_SUCCESSFUL
                Debug-Output "ERGO.INF: MakeServicesEntry failed for Kbdclass"
                goto errorconfig
            endif

        endif

		;
		; Change ErrorControl setting so that service won't log
		; an error if it fails to load.
		;

        ifstr(i) $(CurrentPortEntry) != $(PortDriver)
            ifstr(i) $(CurrentPortEntry) != ""
                ifstr(i) $(CurrentPortEntry) != i8042prt


					LibraryProcedure DontCare, $(!LIBHANDLE), SetupChangeServiceConfig, $(CurrentPortEntry), $(SERVICE_NO_CHANGE), $(SERVICE_NO_CHANGE), 0, "", "", "", "", "", ""
                endif
            endif
        endif

        goto configdone

errorconfig = +
        ifstr(i) $(CurrentPortEntry) != $(PortDriver)
            ifstr(i) $(PortDriver) != ""
                shell "registry.inf" ModifyServicesEntry $(PortDriver) $(!SERVICE_DISABLED)
            endif
            ifstr(i) $(CurrentPortEntry) != ""
                shell "registry.inf" ModifyServicesEntry $(CurrentPortEntry) $(!SERVICE_SYSTEM_START)
            endif
        endif
        ifstr(i) $(CurrentClassEntry) != $(ClassDriver)
            ifstr(i) $(ClassDriver) != ""
                shell "registry.inf" ModifyServicesEntry $(ClassDriver) $(!SERVICE_DISABLED)
            endif
            ifstr(i) $(CurrentClassEntry) != ""
                shell "registry.inf" ModifyServicesEntry $(CurrentClassEntry) $(!SERVICE_SYSTEM_START)
            endif
        endif
        goto finish_InstallOption

configdone = +
    endif

	;
	; Define ErgoTouch applications
	;
	Install AddErgoApps

    set Status = STATUS_SUCCESSFUL
finish_InstallOption = +
    ForListDo $(DrivesToFree)
        LibraryProcedure STATUS,$(!LIBHANDLE), DeleteNetConnection $($) "TRUE"
    EndForListDo

    Return $(Status)

[Install-ErgoDir]
	;
	; Create ErgoTouch software directory on target.
	;
    set STF_VITAL = ""
	CreateDir $(!STF_NTDRIVE)\touch
	CreateDir $(!STF_NTDRIVE)\touch\nt
	exit

[Install-AddCopyOption]

    set STF_VITAL = ""
;	set !STF_DECOMPRESS = 1

    ;
    ; Add the files to the copy list.
	;
	; Note:  we won't add the mouse class driver, because it
	; always gets installed when Windows NT is installed (I hope).
	; If we do decide to add the mouse class driver, we will have
	; to provide another prompt for its SrcDir.
    ;

	AddSectionKeyFileToCopyList	Files-ErgoTouchDrivers			+
								$(PortDriver)					+
								$(SrcDir)						+
								$(!STF_WINDOWSSYSPATH)\drivers

	AddSectionFilesToCopyList	Files-ErgoTouchUtilities		+
								$(SrcDir)						+
								$(!STF_NTDRIVE)\touch\nt

    exit


[Install-DoCopyOption]

    ;
    ; Copy files in the copy list
    ;
    CopyFilesInCopyList
    exit


[AddErgoApps]
	;
	; Create Program Manager group for ErgoTouch Utilities
	;
	CreateCommonProgManGroup "Touch Screen Utilities" ""
	RemoveCommonProgManGroup "Touch Screen Utilities"
	CreateCommonProgManGroup "Touch Screen Utilities" ""
	ShowCommonProgManGroup "Touch Screen Utilities", 1
	CreateCommonProgManItem "Touch Screen Utilities", "Configuration" "\touch\nt\touchcfg.exe" "" 0
	CreateCommonProgManItem "Touch Screen Utilities", "Mouse Button Swap" "\touch\nt\mbswap.exe" "" 0

	exit

;**************************************************************************
; PROGRESS GUAGE VARIABLES
;**************************************************************************

[ProgressCopyENG]
	ProCaption 		= "Windows NT Setup"
	ProCancel		= "Cancel"
	ProCancelMsg	= "Windows NT is not correcly installed."+
					  "Are you sure you want to cancel copying files?"
	ProCancelCap	= "Setup Message"
	ProText1		= "Copying:"
	ProText2		= "To:"

[StringsENG]
	String1			= "Dynapro Thin Film Products"
	String2			= "Please enter the full path to the "+
					  "Dynapro Thin Film software files."+
					  "Then choose Continue."


[ProductType]
STF_PRODUCT  = Winnt
STF_PLATFORM = I386

;-----------------------------------------------------------------------
; SOURCE MEDIA DESCRIPTIONS
; -------------------------
; The OEM should list all the diskette labels here.  The source media
; description is used during copy to prompt the user for a diskette
; if the source is diskettes.
;
; Use 1 = "Diskette 1 Label" , TAGFILE = disk1
;     2 = "Diskette 2 Label" , TAGFILE = disk2
;     ...
;-----------------------------------------------------------------------

;--------------------------------------------------------------------
; THE SECTIONS BELOW SHOULD BE AUTOMATICALLY GENERATED BY THE EXCEL
; SPREAD SHEETS
;--------------------------------------------------------------------
[Source Media Descriptions]
    1 = "Dynapro Thin Film PC2 Software Diskette for Windows NT"  , TAGFILE = disk1

[Files-MouseClassDrivers]
mouclass	= 1,MOUCLASS.SYS,	SIZE=10240

[Files-KeyboardClassDrivers]
kbdclass	= 1,KBDCLASS.SYS,	SIZE=10240

[Files-ErgoTouchDrivers]
ePC2nt		= 1,ePC2nt.sys,	SIZE=128000

[Files-ErgoTouchUtilities]
touchcfg	= 1,touchcfg.exe,	SIZE=196000
touchhlp	= 1,touchcfg.hlp,	SIZE=10240
xvtdll1		= 1,xnmba458.dll,	SIZE=384000	DESTINATION=$(!STF_WINDOWSSYSPATH)
xvtdll2		= 1,xnmhn458.dll,	SIZE=64000	DESTINATION=$(!STF_WINDOWSSYSPATH)
xvtdll3		= 1,xnmte458.dll,	SIZE=64000	DESTINATION=$(!STF_WINDOWSSYSPATH)
xvtdll4     = 1,msvcrt40.dll,	SIZE=64000	DESTINATION=$(!STF_WINDOWSSYSPATH)
defaultini	= 1,default.ini,	SIZE=4096
touchini	= 1,touchini.exe,	SIZE=64000
mbswap		= 1,mbswap.exe,		SIZE=128000
mbswaphlp	= 1,mbswap.hlp,		SIZE=8192
readme		= 1,readme.txt,		SIZE=1024
